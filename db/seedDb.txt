// deletes everything (copy one by one)
MATCH(n) DETACH DELETE n
DROP CONSTRAINT ON (p:TopoNode) ASSERT p.uid IS UNIQUE

// creates the unique id constraint (copy first)
CREATE CONSTRAINT ON (p:`TopoNode`) ASSERT (p.`uid`) IS UNIQUE

// database data seed (copy all the statements in one go)
CREATE (TW: Platform: TopoNode {name:'TW', uid:'plat_0001'})

CREATE (Demand: Domain: TopoNode {name:'Demand', uid:'domain_0001'})
CREATE (Staffing: Domain: TopoNode {name:'Staffing', uid:'domain_0002'})
CREATE (Finance: Domain: TopoNode {name:'Finance', uid:'domain_0003'})
CREATE (People: Domain: TopoNode {name:'People', uid:'domain_0004'})
CREATE (PS: Domain: TopoNode {name:'Professional Services', uid:'domain_0005'})

CREATE(Billing: Capability: TopoNode {name: 'Billing', uid:'cap_0001'})
CREATE(SellingWork: Capability: TopoNode {name: 'Selling work', uid:'cap_0002'})
CREATE(ManagingAccounts: Capability: TopoNode {name: 'Managing Accounts', uid:'cap_0003'})
CREATE(StaffingProjects: Capability: TopoNode {name: 'Staffing projects', uid:'cap_0004'})
CREATE(LeaveTracking: Capability: TopoNode {name: 'Leave tracking', uid:'cap_0005'})
CREATE(InvoicingClients: Capability: TopoNode {name: 'Invoicing clients', uid:'cap_0006'})

CREATE(Salesforce: System {name: 'Salesforce'})
CREATE(SalesFunnel: System {name: 'Sales Tunnel'})
CREATE(Jigsaw: System {name: 'Jigsaw'})
CREATE(LeaveOz: System {name: 'LeaveOz'})

CREATE
  (TW)-[:HAS]->(Demand),
  (TW)-[:HAS]->(Staffing),
  (TW)-[:HAS]->(Finance),
  (TW)-[:HAS]->(People),
  (TW)-[:HAS]->(PS),
  (Demand)-[:DOES]->(SellingWork),
  (Demand)-[:DOES]->(ManagingAccounts),
  (Staffing)-[:DOES]->(StaffingProjects),
  (People)-[:DOES]->(LeaveTracking),
  (PS)-[:DOES]->(Billing),
  (Finance)-[:DOES]->(InvoicingClients),
  (InvoicingClients)-[: SUPPORTEDBY]->(Salesforce),
  (Billing)-[: SUPPORTEDBY]->(Salesforce),
  (SellingWork)-[: SUPPORTEDBY]->(SalesFunnel),
  (ManagingAccounts)-[: SUPPORTEDBY]->(Jigsaw),
  (StaffingProjects)-[: SUPPORTEDBY]->(Jigsaw),
  (LeaveTracking)-[: SUPPORTEDBY]->(LeaveOz)

WITH TW as p
MATCH(p)-[:HAS]->(d) RETURN p, d

// show everything in the db
MATCH(n) RETURN n
